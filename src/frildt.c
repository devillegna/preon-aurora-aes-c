
#include "frildt.h"

#include "merkeltreecommit.h"

#include "string.h"

#if 0

def ldt_commit_phase( vi , poly_len , h_state , RS_rho=8 , RS_shift=1<<63, verbose = 1 ):
    if 1 == verbose : dump = print
    else : dump = _dummy
    assert 0==(poly_len&(poly_len-1)) , 'poly_len is not a power of 2'
    assert len(vi)==poly_len*RS_rho   , 'RS_rho * poly_len != len(vi)'

    commits = []
    mktrees = []

    dump( f"rho: {RS_rho}, offset: {hex(RS_shift)}" )
    dump( f"|original poly| : {poly_len}")
    dump( "\n### commit phase ###" )
    dump( f"Assume the evaluate on [{hex(RS_shift)},|{poly_len}|x{RS_rho}) has been committed." )
    dump( "|v0|:" , len(vi) )
    i = 0
    offset = RS_shift
    while( 2 < poly_len ):
        dump( f"iteration {i}: update : [{poly_len}] -> [{poly_len//2}]:" )
        xi = gf.from_bytes( H.gen( h_state , bytes([3+i,1]) )[:gf.GF_BSIZE] )
        dump( f"derive new challenge xi <- H(h_state||{3+i}||1) : {hex(xi)}" )
        dump( f"deriving new polynomial of length [{poly_len//2}]" )

        #dump( f"v{i-1}: " , list(map(hex,vi)) )
        dump( f"ibtfy_1( |v{i}|:{len(vi)} , {hex(offset)}) ->" )
        vi = gf.ibtfy_1( vi , offset )
        #dump( f"v{i}: " , list(map(hex,vi)) )
        vi_e = vi[::2]
        vi_o = vi[1::2]
        vi = [ vi_e[j]^gf.mul(vi_o[j],xi) for j in range(len(vi_e)) ]
        dump( f"xi:{hex(xi)} * |vi|:{len(vi)} ->" )
        #dump( f"v{i}: " , list(map(hex,vi)) )
        dump( f"evaluated values generated by 1 stage of ibtfy  [{len(vi)}]" )
        offset = offset >> 1
        poly_len = poly_len//2
        i = i+1
        if poly_len <= 2 : break

        mesg = [ gf.to_bytes(vi[j]) + gf.to_bytes(vi[j+1]) for j in range(0,len(vi),2) ]
        root , randomness , tree = mt.commit( mesg )
        mktrees.append( (root,mesg,randomness,tree) )
        commits.append( root )
        dump( f"commit evaluated valuse. --> commits[{len(commits)-1}] <- |mesg|: {len(mesg)}" )
        dump( f"|commits| = {len(commits)}" )

        h_state = H.gen( h_state , gf.to_bytes(xi) , root )
        dump( f"update h_state <- H( h_state|| xi || commit ): {h_state}" )
    #cc = gf.ibtfy_1( vi , offset )     # use btfy_1 for debug only.
    #dump( "ibtfy_1:" , hex(offset) , [hex(e) for e in cc] )
    cc = gf.ifft( vi[:2] , 1 , offset )   # will get the same poly no matter applying ibtfy_1 to whatever pairs. 
    dump( "cc:" , [hex(i) for i in cc ] )
    dump( f"open deg 1 poly: {hex(cc[0])} + x* {hex(cc[1])}" )
    d1poly = gf.to_bytes(cc[0]) + gf.to_bytes(cc[1])
    h_state = H.gen( gf.to_bytes(xi) , d1poly )
    dump( f"update h_state <- H( xi || c0 || c1 ): {h_state}" )
    return commits , d1poly , mktrees , h_state

#endif

#include "utils_hash.h"

int frildt_commit_phase( uint8_t * proof , mt_t mktrees[] , gfvec_t v0 ,  unsigned poly_len , uint8_t *h_state )
{
    int ret = 0;

    uint64_t xi[FRI_HASH_LEN/sizeof(uint64_t)];
    uint8_t *u8ptr_xi = (uint8_t*) xi;
    uint8_t bytes[2] = {3,1};

    uint8_t i = 0;
    uint64_t offset = FRI_RS_SHIFT;
    gfvec_t vi = v0;
    gfvec_t mesg;  if( gfvec_alloc(&mesg,v0.len/2) ) { ret = -1; goto commit_exit; }

    while( 2 < poly_len ) {
        //xi = gf.from_bytes( H.gen( h_state , bytes([3+i,1]) )[:gf.GF_BSIZE] )
        bytes[0] = 3+i;
        hash_2mesg( u8ptr_xi , h_state , FRI_HASH_LEN , bytes , 2 );

        //printf("iter: %d, polylen = %d, vi.len = %d\n", i , poly_len , vi.len );
        //vi = gf.ibtfy_1( vi , offset )
        gfvec_ibtfy_1stage( vi , offset );
        //vi_e = vi[::2] //vi_o = vi[1::2] //vi = [ vi_e[j]^gf.mul(vi_o[j],xi) for j in range(len(vi_e)) ]
        gfvec_frildt_reduce( &vi , xi );

        offset   >>= 1;
        poly_len >>= 1;
        if( poly_len*FRI_RS_RHO != vi.len ) { abort(); } //assert( vi.len == poly_len*FRI_RS_RHO );
        i += 1;
        if ( poly_len <= 2 ) break;

        //mesg = [ gf.to_bytes(vi[j]) + gf.to_bytes(vi[j+1]) for j in range(0,len(vi),2) ]
        gfvec_to_consecutive_form( mesg , vi );
        //root , randomness , tree = mt.commit( mesg )
        //mktrees.append( (root,mesg,randomness,tree) )
        //printf( "mktrees[i-1].num_mesg = %d, poly_len*FRI_RS_RHO/2 = %d\n" , mktrees[i-1].num_mesg , poly_len*FRI_RS_RHO/2 );
        if( mt_commit( mktrees[i-1] , (uint8_t*)mesg.sto , FRI_MT_MESG_LEN , poly_len*FRI_RS_RHO/2 ) ) { ret=-1; goto commit_clean_exit; }
        // mt_commit( mktrees[i-1] , (uint8_t*)mesg.sto , FRI_MT_MESG_LEN , poly_len*FRI_RS_RHO/2 )

        //commits.append( root )
        memcpy( proof , mktrees[i-1].root , FRI_HASH_LEN );   proof += FRI_HASH_LEN;

        //h_state = H.gen( h_state , gf.to_bytes(xi) , root )
        hash_3mesg( h_state , h_state , FRI_HASH_LEN , u8ptr_xi , FRI_GF_BYTES , mktrees[i-1].root , FRI_HASH_LEN );
    }
    //cc = gf.ifft( vi[:2] , 1 , offset )   # will get the same poly no matter applying ibtfy_1 to whatever pairs. 
    vi.len = 2;
    gfvec_ibtfy_1stage( vi , offset );

    //dump( "cc:" , [hex(i) for i in cc ] )
    //dump( f"open deg 1 poly: {hex(cc[0])} + x* {hex(cc[1])}" )
    //d1poly = gf.to_bytes(cc[0]) + gf.to_bytes(cc[1])
    gfvec_to_consecutive_form( mesg , vi );
    memcpy( proof , mesg.sto , 2*FRI_GF_BYTES );  proof += 2*FRI_GF_BYTES;

    //h_state = H.gen( gf.to_bytes(xi) , d1poly )
    hash_2mesg( h_state , h_state , FRI_HASH_LEN , (uint8_t*)mesg.sto , 2*FRI_GF_BYTES );
    //dump( f"update h_state <- H( xi || c0 || c1 ): {h_state}" )
    //return commits , d1poly , mktrees , h_state

commit_clean_exit:
    gfvec_free(&mesg);
commit_exit:
    return ret;
}



#if 0
def ldt_query_phase( f_length , mktrees, h_state , Nq , RS_rho=8 , verbose = 1 ):
    if 1 == verbose : dump = print
    else : dump = _dummy
    assert Nq < 256 , "need to modify hash inputs if supporting >= 256 queries."

    dump( "\n### query phase ###" )
    dump( f"queries = [ H.gen(h_state , {3+ldt_n_commit(f_length)+1} , j )  for j in range(1,{Nq+1})]")
    queries = [ H.gen(h_state,bytes( [ 3+ldt_n_commit(f_length)+1 , j ] ))[:4] for j in range(1,Nq+1) ]   # use 32 bits of hash results only
    idx_mask = (RS_rho*f_length//2)-1
    queries = [ int.from_bytes(e,'little')&idx_mask for e in queries ]
    _queries = list(queries)
    dump( f"Queries: [{len(queries)}], {queries}" )
#endif

static void frildt_get_queries( uint32_t * queries , const uint8_t * h_state ) {
#if FRI_N_QUERY >= 256 
FRI_N_QUERY error: QUERY overflow.
#endif
#if FRI_CORE_N_COMMITS >=253
FRI_CORE_N_COMMITS error: QUERY overflow.
#endif
    //queries = [ H.gen(h_state,bytes( [ 3+ldt_n_commit(f_length)+1 , j ] ))[:4] for j in range(1,Nq+1) ]   # use 32 bits of hash results only
    //idx_mask = (RS_rho*f_length//2)-1
    //queries = [ int.from_bytes(e,'little')&idx_mask for e in queries ]

    uint32_t h32_state[FRI_HASH_LEN/sizeof(uint32_t)];
    uint8_t bytes[2] = { 3 + FRI_CORE_N_COMMITS , 0};
    uint32_t idx_mask = FRI_MT_N_MESG*2 - 1;
    for(uint8_t j=1;j<=FRI_N_QUERY;j++) {
        hash_2mesg( h32_state , h_state , FRI_HASH_LEN , bytes , 2 );
        queries[j-1] = h32_state[0]&idx_mask;
    }
}

#if 0
def ldt_query_phase( f_length , mktrees, h_state , Nq , RS_rho=8 , verbose = 1 ):
    #...
    # no need to open valuse of f_0
    queries = [ q//2 for q in queries ]

    open_mesgs = []
    j = 0
    for root , all_mesg, randomness, tree in mktrees :
        dump( f"open iteration: {j}" )
        open_mesgs.append( mt.batchopen(queries,all_mesg,randomness,tree) )
        dump( f"proof len:[{len(open_mesgs)}] : auth path len:{len(open_mesgs[-1][0])}" )
        queries = [ q//2 for q in queries ]
        j = j+1
    return open_mesgs , _queries
#endif

static void frildt_batchopen( uint8_t * proof , mt_t mktrees[] , const uint32_t * queries ) {
    uint32_t qq[FRI_N_QUERY];
    for(int i=0;i<FRI_N_QUERY;i++) qq[i] = queries[i]>>1;

    for(int j=0;j<FRI_CORE_N_COMMITS;j++) {
        // open ....


    }
}


#if 0
def ldt_gen_proof( f0 , h_state , Nq = 26 , RS_rho = 8 , verbose = 1 ):
    if 1 == verbose : dump = print
    else : dump = _dummy

    RS_shift = 1<<63
    v0 = gf.fft( f0 , RS_rho , RS_shift )
    dump( f"do a redundent commit for v_f0 here for checking correctness" )
    mesg0 = [ gf.to_bytes(v0[j]) + gf.to_bytes(v0[j+1]) for j in range(0,len(v0),2) ]
    rt0 , rd0 , tree0 = mt.commit( mesg0 )   # first commit

    commits , d1poly , mktrees , h_state = ldt_commit_phase( v0 , len(f0) , h_state , RS_rho , RS_shift , verbose )
    open_mesgs , queries = ldt_query_phase( len(f0) , mktrees , h_state , Nq , RS_rho , verbose )

    proof = [rt0]
    proof.extend( commits )
    proof.append( d1poly )
    proof.extend( open_mesgs )
    proof.append( mt.batchopen(queries,mesg0,rd0,tree0) )  # opened messages of first commit
    return proof
#endif


int frildt_gen_proof( uint8_t * proof , const gfvec_t *f0, const uint8_t *ih_state )
{
    gfvec_t v0;
    gfvec_alloc( &v0 , FRI_POLYLEN*FRI_RS_RHO );
    gfvec_fft( v0, *f0 , FRI_RS_SHIFT);

    mt_t mkt;
    mt_init( &mkt , v0.len/2 );
    gfvec_t gfmesg;
    gfvec_alloc( &gfmesg , v0.len );
    gfvec_to_consecutive_form( gfmesg , v0 );
    mt_commit( mkt , (uint8_t*)gfmesg.sto , FRI_MT_MESG_LEN , FRI_MT_N_MESG );


    frildt_proof_t ptr_proof;
    frildt_proof_setptr( &ptr_proof , proof );
    //printf("proof size: %d\n", size );
    memcpy( ptr_proof.first_commit , mkt.root , FRI_HASH_LEN );  // output first commit

    uint8_t h_state[FRI_HASH_LEN];  memcpy( h_state , ih_state , FRI_HASH_LEN );
    mt_t mkts[FRI_CORE_N_COMMITS];
    for(int i=0;i<FRI_CORE_N_COMMITS;i++) { mt_init( &mkts[i] , FRI_MT_N_MESG>>(1+i) ); }
    if( 0 != frildt_commit_phase( ptr_proof.commits[0] , mkts , v0 , FRI_POLYLEN , h_state ) ) { printf("fri commit phase fails.\n"); abort(); }
    // frildt_commit_phase( ptr_proof.commits[0] , mkts , v0 , FRI_POLYLEN , h_state );





    mt_open( ptr_proof.first_mesgs , mkt , ((uint8_t*)gfmesg.sto) + FRI_MT_MESG_LEN*3 , FRI_MT_MESG_LEN , 3 );  // open first commit


    for(int i=0;i<FRI_CORE_N_COMMITS;i++) { mt_free( &mkts[i] ); }

    gfvec_free( &gfmesg );
    mt_free( &mkt );
    gfvec_free( &v0 );
    return 0;
}




#if 0
def ldt_recover_challenges( _poly_len , h_state , commits , d1poly , Nq , RS_rho = 8 , verbose = 1 ):
    if 1 == verbose : dump = print
    else : dump = _dummy

    dump( "######## recovery hash state and challenges ########" )
    poly_len = _poly_len
    i = 0
    xi = []
    while( 2 < poly_len ):
        dump( f"iteration {i}: [{poly_len}] -> [{poly_len//2}]:" )
        xi.append( gf.from_bytes( H.gen( h_state , bytes([3+i,1]) )[:gf.GF_BSIZE] ) )
        dump( f"derive new challenge xi <- H(h_state||{3+i}||1) : {hex(xi[-1])}" )
        dump( f"new polynomial length [{poly_len//2}]" )
        poly_len = poly_len//2
        if poly_len <= 2 : break
        dump( f"mt.root = commits[{i}] = " ,  commits[i] )
        h_state = H.gen( h_state , gf.to_bytes(xi[i]) , commits[i] )
        dump( f"update h_state <- H( h_state|| xi || commit ): {h_state}" )
        i = i+1
    h_state = H.gen( gf.to_bytes(xi[-1]) , d1poly )
    dump( f"update h_state <- H( xi || deg1poly ): {h_state}" )

    dump( "\n### query phase ###" )
    dump( f"queries = [ H.gen(h_state , {3+i+1}=={3+ldt_n_commit(_poly_len)+1} , j )  for j in range(1,{Nq+1})]")
    queries = [ H.gen(h_state,bytes( [ 3+i+1 , j ] ))[:4] for j in range(1,Nq+1) ]
    idx_mask = (RS_rho*_poly_len//2)-1
    queries = [ int.from_bytes(e,'little')&idx_mask for e in queries ]
    dump( f"Queries: [{len(queries)}], {queries}" )
    return xi , queries



def ldt_verify_proof( commits , d1poly , first_mesgs , open_mesgs , xi , queries , RS_shift=1<<63 , verbose = 1 ):
    if 1 == verbose : dump = print
    else : dump = _dummy

    dump( "#### check linear relations and opened commit ######" )
    offset = RS_shift
    j = 0
    # check first_mesgs
    if True :
        # check linear relations
        dump( f"check linear relations:" )
        mesg      = first_mesgs   # [ path[0] for path in first_mesgs ]
        next_mesg = [ path[0] for path in open_mesgs[0] ]
        verify_j  = [ _check_linear_relation(mesg[i],next_mesg[i],q,xi[j],offset) for i,q in enumerate(queries) ]
        dump( f"check linear relations:" , all(verify_j) )
        if not all(verify_j) : return False
        queries = [ q//2 for q in queries ]
        offset >>= 1
        j = j+1

    for idx,auths in enumerate(open_mesgs) :
        dump( f"open iteration: {j}" )
        dump( f"auths[{len(auths[0])}]: Nbyte: ", sum( map( len,auths[0]) ) )
        if not mt.batchverify( queries , commits[j-1] , auths ) :
            dump("batchverify() fails")
            return False
        else : dump("oepned mesgs are verified.")

        # check linear relations
        mesg = [ path[0] for path in auths ]
        if idx == len(open_mesgs)-1 : break
        dump( f"check linear relations [{idx}]:" )
        next_mesg = [ path[0] for path in open_mesgs[idx+1] ]
        verify_j  = [ _check_linear_relation(mesg[i],next_mesg[i],q,xi[j],offset) for i,q in enumerate(queries) ]
        dump( f"check linear relations [{idx}]:" , all(verify_j) )
        if not all(verify_j) : return False
        queries = [ q//2 for q in queries ]
        offset >>= 1
        j = j+1
    # check deg 1 poly
    verify_j = [ _check_deg1poly_linear_relation(mesg[i],d1poly,q,xi[-1],offset) for i,q in enumerate(queries) ]
    dump( f"check last linear relations (with the d1poly):" , all(verify_j) )
    if not all(verify_j) : return False
    return True

def _check_linear_relation( mesgj1 , mesgj0 , idx , xi , offset ) :
    new_j0 = gf.from_bytes_x2( mesgj0 )
    org_j1 = gf.from_bytes_x2( mesgj1 )
    org_j0 = gf.ibtfy_1( org_j1 , offset^(idx<<1) )
    cc1 = org_j0[0] ^ gf.mul( org_j0[1] , xi )
    return new_j0[idx&1] == cc1

def _check_deg1poly_linear_relation( mesgjm1 , d1poly , idx , xi , offset ) :
    m0 = gf.fft( gf.from_bytes_x2(d1poly) , 1 , (offset>>1)^(idx^(idx&1)) )
    return _check_linear_relation( mesgjm1 , gf.to_bytes(m0[0])+gf.to_bytes(m0[1]) , idx , xi , offset )
#endif

#if 0
def ldt_verify( proof , _poly_len , h_state , Nq = 26 , RS_rho = 8 , verbose = 1 ):
    n_commits = ldt_n_commit( _poly_len )
    first_commit = proof[0]
    commits     = proof[1:1+n_commits]
    d1poly      = proof[1+n_commits]
    open_mesgs  = proof[2+n_commits:2+n_commits+n_commits]
    first_mesgs = proof[2+n_commits+n_commits]
    xi, queries = ldt_recover_challenges(_poly_len,h_state,commits,d1poly,Nq, RS_rho, verbose )

    if not mt.batchverify( queries , first_commit , first_mesgs ) : return False

    return ldt_verify_proof(commits,d1poly,[path[0] for path in first_mesgs],open_mesgs,xi,queries,1<<63,verbose)
#endif

int frildt_verify( const uint8_t * proof , unsigned poly_len , const uint8_t *h_state )
{
    frildt_proof_t ptr_proof;
    frildt_proof_setptr( &ptr_proof , (uint8_t *)proof );

    return mt_verify( ptr_proof.first_commit , ptr_proof.first_mesgs , FRI_MT_MESG_LEN , FRI_MT_N_MESG , 3 );
}
